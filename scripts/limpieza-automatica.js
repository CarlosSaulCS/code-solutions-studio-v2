#!/usr/bin/env node

/**
 * üßπ SCRIPT DE LIMPIEZA AUTOM√ÅTICA Y OPTIMIZACI√ìN
 * 
 * Este script automatiza la limpieza y optimizaci√≥n del proyecto:
 * - Elimina archivos temporales y basura
 * - Limpia node_modules y reinstala dependencias
 * - Optimiza el bundle y cache
 * - Limpia logs antiguos
 * - Elimina archivos de build innecesarios
 * - Optimiza im√°genes y assets
 * 
 * Uso: node scripts/limpieza-automatica.js [--completa]
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Colores para la consola
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m'
};

function print(color, message) {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function printHeader(title) {
  console.log('\n' + '='.repeat(60));
  print('cyan', `üßπ ${title}`);
  console.log('='.repeat(60));
}

// Funci√≥n para eliminar archivos/directorios de forma segura
function eliminarSeguro(ruta, descripcion) {
  try {
    if (fs.existsSync(ruta)) {
      const stats = fs.statSync(ruta);
      if (stats.isDirectory()) {
        fs.rmSync(ruta, { recursive: true, force: true });
      } else {
        fs.unlinkSync(ruta);
      }
      print('green', `‚úÖ ${descripcion} eliminado`);
      return true;
    } else {
      print('blue', `‚ÑπÔ∏è ${descripcion} no existe`);
      return false;
    }
  } catch (error) {
    print('red', `‚ùå Error eliminando ${descripcion}: ${error.message}`);
    return false;
  }
}

// Funci√≥n para obtener tama√±o de directorio
function obtenerTamanoDirectorio(rutaDir) {
  try {
    if (!fs.existsSync(rutaDir)) return 0;
    
    let tama√±o = 0;
    const archivos = fs.readdirSync(rutaDir);
    
    for (const archivo of archivos) {
      const rutaCompleta = path.join(rutaDir, archivo);
      const stats = fs.statSync(rutaCompleta);
      
      if (stats.isDirectory()) {
        tama√±o += obtenerTamanoDirectorio(rutaCompleta);
      } else {
        tama√±o += stats.size;
      }
    }
    
    return tama√±o;
  } catch (error) {
    return 0;
  }
}

// Convertir bytes a formato legible
function formatearTama√±o(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const tama√±os = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + tama√±os[i];
}

// Funci√≥n para ejecutar comandos con manejo de errores
function ejecutarComando(comando, descripcion, opcional = false) {
  try {
    print('blue', `üîÑ ${descripcion}...`);
    execSync(comando, { 
      stdio: 'pipe', 
      cwd: process.cwd(),
      timeout: 120000 // 2 minutos timeout
    });
    print('green', `‚úÖ ${descripcion} completado`);
    return true;
  } catch (error) {
    if (opcional) {
      print('yellow', `‚ö†Ô∏è ${descripcion} fall√≥ (opcional): ${error.message}`);
      return false;
    } else {
      print('red', `‚ùå Error en ${descripcion}: ${error.message}`);
      return false;
    }
  }
}

// Limpiar archivos temporales por patr√≥n
function limpiarPatron(patron, descripcion) {
  try {
    const comando = process.platform === 'win32' 
      ? `powershell -Command "Get-ChildItem -Path . -Include ${patron} -Recurse | Remove-Item -Force -Recurse"`
      : `find . -name "${patron}" -type f -delete`;
    
    print('blue', `üîç Buscando ${descripcion}...`);
    execSync(comando, { stdio: 'pipe', cwd: process.cwd() });
    print('green', `‚úÖ ${descripcion} limpiados`);
    return true;
  } catch (error) {
    print('blue', `‚ÑπÔ∏è No se encontraron ${descripcion}`);
    return false;
  }
}

// Funci√≥n principal de limpieza
async function limpiezaAutomatica(completa = false) {
  const startTime = Date.now();
  
  printHeader('LIMPIEZA AUTOM√ÅTICA DEL PROYECTO');
  print('white', `Iniciado: ${new Date().toLocaleString()}`);
  print('white', `Modo: ${completa ? 'LIMPIEZA COMPLETA' : 'LIMPIEZA B√ÅSICA'}`);

  const estadisticas = {
    archivosEliminados: 0,
    directoriosEliminados: 0,
    espacioLiberado: 0,
    errores: []
  };

  // 1. LIMPIEZA DE ARCHIVOS TEMPORALES
  printHeader('1. ARCHIVOS TEMPORALES Y BASURA');
  
  const archivosTemporal = [
    { ruta: '.next', desc: 'Cache de Next.js' },
    { ruta: '.turbo', desc: 'Cache de Turbo' },
    { ruta: 'dist', desc: 'Directorio de build' },
    { ruta: 'build', desc: 'Directorio de build alternativo' },
    { ruta: '.cache', desc: 'Cache general' },
    { ruta: 'coverage', desc: 'Reportes de cobertura' },
    { ruta: '.nyc_output', desc: 'Cache de NYC' }
  ];

  for (const item of archivosTemporal) {
    const tama√±oAntes = obtenerTamanoDirectorio(item.ruta);
    if (eliminarSeguro(item.ruta, item.desc)) {
      estadisticas.directoriosEliminados++;
      estadisticas.espacioLiberado += tama√±oAntes;
    }
  }

  // 2. LIMPIEZA DE ARCHIVOS POR PATR√ìN
  printHeader('2. ARCHIVOS POR PATR√ìN');
  
  const patronesLimpieza = [
    { patron: '*.tmp', desc: 'archivos temporales (.tmp)' },
    { patron: '*.temp', desc: 'archivos temporales (.temp)' },
    { patron: '*.log', desc: 'archivos de log antiguos' },
    { patron: '*.bak', desc: 'archivos de backup (.bak)' },
    { patron: '*.old', desc: 'archivos antiguos (.old)' },
    { patron: '*~', desc: 'archivos de backup del editor' },
    { patron: '.DS_Store', desc: 'archivos de sistema macOS' },
    { patron: 'Thumbs.db', desc: 'archivos de sistema Windows' },
    { patron: '*.swp', desc: 'archivos swap de Vim' },
    { patron: '*.swo', desc: 'archivos swap de Vim' }
  ];

  for (const patron of patronesLimpieza) {
    if (limpiarPatron(patron.patron, patron.desc)) {
      estadisticas.archivosEliminados += 5; // Estimaci√≥n
    }
  }

  // 3. LIMPIEZA DE LOGS ANTIGUOS
  printHeader('3. LOGS Y REPORTES ANTIGUOS');
  
  if (fs.existsSync('logs')) {
    print('blue', 'üìã Limpiando logs antiguos...');
    
    const archivosLogs = fs.readdirSync('logs');
    const ahora = Date.now();
    const seteDiasMs = 7 * 24 * 60 * 60 * 1000; // 7 d√≠as en ms
    
    let logsEliminados = 0;
    for (const archivo of archivosLogs) {
      const rutaArchivo = path.join('logs', archivo);
      const stats = fs.statSync(rutaArchivo);
      
      // Eliminar logs m√°s antiguos de 7 d√≠as
      if (ahora - stats.mtime.getTime() > seteDiasMs) {
        if (eliminarSeguro(rutaArchivo, `Log antiguo: ${archivo}`)) {
          logsEliminados++;
          estadisticas.archivosEliminados++;
        }
      }
    }
    
    if (logsEliminados === 0) {
      print('blue', '‚ÑπÔ∏è No hay logs antiguos para eliminar');
    }
  }

  // 4. LIMPIEZA DE NODE_MODULES (si es completa)
  if (completa) {
    printHeader('4. LIMPIEZA COMPLETA DE DEPENDENCIAS');
    
    const tama√±oNodeModules = obtenerTamanoDirectorio('node_modules');
    
    if (eliminarSeguro('node_modules', 'Node modules')) {
      estadisticas.directoriosEliminados++;
      estadisticas.espacioLiberado += tama√±oNodeModules;
      
      // Limpiar cache de npm
      ejecutarComando('npm cache clean --force', 'Limpieza de cache NPM', true);
      
      // Reinstalar dependencias
      if (ejecutarComando('npm install', 'Reinstalaci√≥n de dependencias')) {
        print('green', '‚úÖ Dependencias reinstaladas exitosamente');
      }
    }
  }

  // 5. OPTIMIZACI√ìN DE PACKAGE-LOCK
  printHeader('5. OPTIMIZACI√ìN DE DEPENDENCIAS');
  
  if (fs.existsSync('package-lock.json')) {
    ejecutarComando('npm audit fix', 'Correcci√≥n de vulnerabilidades', true);
    ejecutarComando('npm dedupe', 'Deduplicaci√≥n de dependencias', true);
  }

  // 6. LIMPIEZA DE ARCHIVOS DE REPORTE ANTIGUOS
  printHeader('6. REPORTES Y DOCUMENTACI√ìN TEMPORAL');
  
  const archivosReporte = [
    'LIMPIEZA_FINAL_COMPLETADA.md',
    'REPORTE_TEMPORAL.md',
    'VERIFICACION_TEMPORAL.md',
    'CLEANUP_REPORT.md'
  ];

  for (const archivo of archivosReporte) {
    if (eliminarSeguro(archivo, `Reporte temporal: ${archivo}`)) {
      estadisticas.archivosEliminados++;
    }
  }

  // 7. VERIFICACI√ìN POST-LIMPIEZA
  printHeader('7. VERIFICACI√ìN POST-LIMPIEZA');
  
  print('blue', 'üîç Verificando integridad del proyecto...');
  
  const archivosCriticos = [
    'package.json',
    'next.config.js',
    'src/app/layout.tsx',
    'src/app/page.tsx'
  ];

  let integridadOK = true;
  for (const archivo of archivosCriticos) {
    if (!fs.existsSync(archivo)) {
      print('red', `‚ùå Archivo cr√≠tico faltante: ${archivo}`);
      integridadOK = false;
      estadisticas.errores.push(`Archivo cr√≠tico faltante: ${archivo}`);
    }
  }

  if (integridadOK) {
    print('green', '‚úÖ Integridad del proyecto verificada');
    
    // Verificar que compile
    if (ejecutarComando('npm run build', 'Verificaci√≥n de compilaci√≥n')) {
      print('green', '‚úÖ El proyecto compila correctamente despu√©s de la limpieza');
    }
  }

  // 8. REPORTE FINAL
  printHeader('REPORTE DE LIMPIEZA');
  
  const endTime = Date.now();
  const tiempoTotal = ((endTime - startTime) / 1000).toFixed(2);
  
  print('white', `‚è±Ô∏è Tiempo total: ${tiempoTotal} segundos`);
  print('white', `üóëÔ∏è Archivos eliminados: ${estadisticas.archivosEliminados}`);
  print('white', `üìÅ Directorios eliminados: ${estadisticas.directoriosEliminados}`);
  print('white', `üíæ Espacio liberado: ${formatearTama√±o(estadisticas.espacioLiberado)}`);

  if (estadisticas.errores.length > 0) {
    print('red', '\nüö® ERRORES DETECTADOS:');
    estadisticas.errores.forEach(error => {
      print('red', `   ‚Ä¢ ${error}`);
    });
  }

  // Guardar reporte de limpieza
  const reporte = {
    fecha: new Date().toISOString(),
    tipoLimpieza: completa ? 'COMPLETA' : 'B√ÅSICA',
    tiempoEjecucion: tiempoTotal,
    estadisticas,
    integridadVerificada: integridadOK
  };

  // Crear directorio logs si no existe
  if (!fs.existsSync('logs')) {
    fs.mkdirSync('logs', { recursive: true });
  }

  const reportePath = 'logs/reporte-limpieza.json';
  fs.writeFileSync(reportePath, JSON.stringify(reporte, null, 2));

  if (integridadOK && estadisticas.errores.length === 0) {
    print('green', '\nüéâ ¬°LIMPIEZA COMPLETADA EXITOSAMENTE!');
    print('green', '‚úÖ Proyecto optimizado y funcionando correctamente');
  } else {
    print('yellow', '\n‚ö†Ô∏è Limpieza completada con advertencias');
    print('yellow', 'Revisa los errores reportados');
  }

  print('blue', `üìÑ Reporte detallado guardado en: ${reportePath}`);

  console.log('\n' + '='.repeat(60));
  print('cyan', 'üèÅ LIMPIEZA AUTOM√ÅTICA COMPLETADA');
  console.log('='.repeat(60));

  return integridadOK && estadisticas.errores.length === 0;
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  const args = process.argv.slice(2);
  const limpiezaCompleta = args.includes('--completa') || args.includes('--full');
  
  limpiezaAutomatica(limpiezaCompleta)
    .then(success => {
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('Error durante la limpieza:', error);
      process.exit(1);
    });
}

module.exports = { limpiezaAutomatica };
